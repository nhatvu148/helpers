---------------------------------------------------------------------------------------------------------------
/ *METHODS /
---------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------
# Strings
---------------------------------------------------------------------------------------------------------------
length() # Shows length of the string (works only for strings)
size() # Same as length() but works for other structures as well
back() # Returns the last character of the string
front() # Returns the first character of the string
append(value) # Add something in the end
insert(index, value) # Add an character in in a secific index
pop_back() # Remove the last character
erase(start, end) # Remove a specific range, the end excluded and if you give only argument it will remove only one element
find("character", index to start) # Shows the index of a character or a string (second parameter is optinal)
find_first_of("characters") # Returns the index of the first of this characters it will found
replace(start, end, "characters") # Replace a part of a string with something else
substr(index,length) # Take a specific part from a string
compare(other_string) # compare with another string if they are equal it returns 0
toUperCase() # Makes all leters of a variable upercase
toLowerCase() # Makes all leters of a variable lowercase

---------------------------------------------------------------------------------------------------------------
# Vectors
---------------------------------------------------------------------------------------------------------------
begin() # Returns an iterator pointing to the first element
end() # Returns an iterator pointing to the theoretical element that follows the last element
assign(times, value) # Assigns new value to the vector elements by replacing the every old one
push_back(value) # Add an element in the end
pop_back() # Remove the last element
insert(index, value) # Add an element in in a secific index
clear() # Remove every element and clear the vector
swap() # Swap the contents of a vector with another vector
size() # Shows the number of elements
max_size() # Shows the max number of elements the vector can hold
capacity() # Returns the size of the storage space currently allocated as number of elements
shrink_to_fit() # Reduces the capacity of the container and destroys all elements beyond the capacity

---------------------------------------------------------------------------------------------------------------
# Files
---------------------------------------------------------------------------------------------------------------
open("file", mode) # Open a file, if the mode is not given it will delete the previous data and add the new
close() # Close a file
is_open() # Returns true if the file is opend and false if not
get() # Get characters from a file

---------------------------------------------------------------------------------------------------------------
/ *FUNCTIONS /
---------------------------------------------------------------------------------------------------------------
getline(stream, variable) # Get a line
sizeof(value) # Shows the size of a value in bytes
stoi(value) # Convert a value to an intiger
stof(value) # Convert a value to a float
stod(value) # Convert a value to a double
to_string(value) # Convert a value to a string
isalnum(value) # Check if something is a a letter or a number
isalpha(age) # Check if something is a letter
isdigit(value) # Check if something is a number
isspace(value) # Check if something is a space
---------------------------------------------------------------------------------------------------------------
# Cmath
---------------------------------------------------------------------------------------------------------------
abs(num) # Returns the absolute value of the num
fmax(num1, num2) # Returns the bigger number if they are equal a is returned
fmin(num1, num2) # Returns the smaller number if they are equal a is returned
pow(num1,num2) # Rises the num1 to the power of num2
sqrt(num) # Give us the square root of num
cbrt(num) # Give us the cubic root of num
round(num) # Will round num up or down depend the float point number
ceil(num) # Will round num up
floor(num) # Will round num down
remainder(num1, num2) # Will divide num1 with num2 and it will return the remainer, float support
---------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------
/ *DATA TYPES /
---------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------
# Characters
---------------------------------------------------------------------------------------------------------------
Characters are values
consisting of just one
character. Their size
is 1 byte. We use them
inside single quotes (')

Example:
'C'

We can use espace sequence to
use some special characters
We use them with a backslash (\)

Exaple:
\" // To insert a double quote
\\ // To insert a backslash
\n // To insert a new line
\b // To insert a backspace
\t // To insert a tab
\v // To insert a vertical tab
\f // To replace everything before it with spaces
\r // To remove everything before it

---------------------------------------------------------------------------------------------------------------
# Strings
---------------------------------------------------------------------------------------------------------------
A string is a sequence
of characters. They are
enclosed inside double
quotes ("). If we want
to use a double quote
we need to escape it (\")
If we add the letter R
before the string then
it will ignore escapes

Example:
"This is a string"
R"This string will ignore every escape sequence like \n"

---------------------------------------------------------------------------------------------------------------
# Intigers
---------------------------------------------------------------------------------------------------------------
Intigers are whole numbers
both positive and negative
They come in different types
based on their size and if they
can store negative values or not

// Name                     // Size        // Value range
char                        1byte          -128 to 127
unsigned char               1byte          0 to 255
short int                   2bytes         -32768 to 32767
unsigned short int          2bytes         0 to 65,535
int                         4bytes         -2147483648 to 2147483647
unsigned int                4bytes         0 to 4294967295
long int                    8bytes         -2,147,483,648 to 2,147,483,647
unsigned long int           8bytes         0 to 4,294,967,295
long long int               8bytes         -(2^63) to (2^63)-1
unsigned long long int      8bytes         0 to 18446744073709551615

---------------------------------------------------------------------------------------------------------------
# Floats
---------------------------------------------------------------------------------------------------------------
Floats are floating point numbers
Like intigers they also come in different types
depending on their size and precision

// Name        // Size                    // Values they can take               // Precision
float          4bytes                     ±1.18 x 10-38 to ±3.4 x 1038          6-9 digits, typically 7
double         8bytes                     ±2.23 x 10-308 to ±1.80 x 10308       15-18 digits, typically 16
long double    80 bit (12 or 16 bytes)    ±3.36 x 10-4932 to ±1.18 x 104932s    18-21 digits

Arithmetic Operators
They are used for intigers, floats and strings
There are five

Addition(+)          returns the sum of the values
Subtraction(-)       returns the difference of the values
Multiplication(*)    returns the product of the values
Division(/)          performs division operation and returns the quotient
Modulus(%)           performs division operation and returns the remainder

---------------------------------------------------------------------------------------------------------------
# Booleans
---------------------------------------------------------------------------------------------------------------
A boolean can take two values: true or false

We can use some specific
operators with them and
do arithmetic operations

bitwise AND(&)        Both of them must be true
bitwise OR(|)         At least one of them must be true
bitwise XOR(^)        One of the two must be true but not both

// Left expression    // Operator    // Right expression    // Result
false                 &              false                  false
false                 &              true                   false
true                  &              false                  false
true                  &              true                   true

// Left expression    // Operator    // Right expression    // Result
false                 |              false                  false
false                 |              true                   true
true                  |              false                  true
true                  |              true                   true

// Left expression    // Operator    // Right expression    // Result
false                 ^              false                  false
false                 ^              true                   true
true                  ^              false                  true
true                  ^              true                   false

---------------------------------------------------------------------------------------------------------------
/ *CORE LANGUAGE /
---------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------
# The main function
---------------------------------------------------------------------------------------------------------------
Every program has something called the "main"
function. This is where our program starts to
read and execute code line by line starting from
the top to the button. We need to create it in
every program. Every code in the following examples
can be plased inside the main function so I will
not creating it all the time. You may put some things
out like classes, functions, enums, etc but probably
everything will work even if you put them inside the
main function.

Example:
// Inuclude a file that we need
#inculde <iostream>
// int is the return type
// main is the name of the function
// and everything is being placed inside
// these curly brackets. Everyith will
// get explained in detail in the following
// sections
int main() {
    // This line will print "Hello world!" to
    // the terminal screen. Keep in mind that spaces
    // between lines and words doesn't matter
    // After each statment, we add a semicolon (;)
    cout << "Hello, world!" << endl;



    // We could also have wrote it this way
    // cout<<     "Hello, world!"     <<endl;

    // In the end, we return 0 which means
    // that our program ended successfully
    // This is optinal
    return 0;
}

---------------------------------------------------------------------------------------------------------------
# Comments
---------------------------------------------------------------------------------------------------------------
Comments are ignored by the compiler
We use them to explain what our code does

We can use single line comments with two slashes (//)
We can use multi line comments with slash and asterisk (/*)
and close them with asterisk and slash (*/)

Example:
// This is a singe line comment!

/* This is a
multiline comment*/

---------------------------------------------------------------------------------------------------------------
# Variables
---------------------------------------------------------------------------------------------------------------
A variable is a container that stores
a value we can access any time. To create
variable we specify their type and we give
them a name. To use the build in string type
we must include the "string" header file

Example:
// Include the file
#include <string>

// Here is something special. We will use the next line
// to use a namespace. This will let use use things like
// "string" without saying "std::string". I'll explain namespaces later
// I suppose that you are going to use this all the time
// so just like main, I won't type this again (except for when I talk about namespaces)
using namespace std;

// To create a char
char character = 'C';
// To create a string (array of characters)
char name[] = "John";
// To create a const char* pointer string (C way)
char* name = "John";
// To create a string (C++ way)
string name = "John";
// To create an intiger number
int age = 18;
// To create a float
float exact_age = 18.8;
// To create a boolean
bool is_male = true;
// This variable will get the
// type automatically besed on
// the return value it can really help
// with readability in some cases
auto this_is_a_character = 'C';

// We can also diclare a varible without
// asign a value to it. And also diclare
// multiple variable in the same line by
// separating them with comma (,). The variable
// must be the same type for this to work

Example:
// This will create three intiger variables
int num1, num2, num3;
// This will create three intiger variables and also asign values to them
int num4 = 10, num5 = 20, num6 = 30;

Strings can also be indexed to access a specif character
And we can also copy another string starting from a specify index

Example:
string name = "Big John";
// Change the second character
name[1] = 'a';
// Print the second character
cout << name[1] << endl;
// Print the last character
cout << name[name.length() - 1] << endl;
// Crate a new string that will copy name starting from the 4th index
string small_name(name, 4);

We can also do arithmetic operations
of variables of the same type

Example:
string hello = "Hello";
string world = "world!";
// This will print Hello world!
cout << hello + " " + world << endl;

---------------------------------------------------------------------------------------------------------------
# Output
---------------------------------------------------------------------------------------------------------------
To print something we use the "cout" function and
then the insertion operator (<<) We can also use
the "endl" keyword to end to add a newline character
First we need to include the "iostream" library

Example:
// Include the file
#include <iostream>

// This will print Hello world
cout << "Hello world!";
// This will print Hello world and it will add a newline
cout << "Hello world!" << endl;
// This will also print Hello world
cout << "Hello" << " " << "world!" << endl;
// This will also print Hello world combining all strings together
cout << "Hello" + " " + "world!" << endl;

---------------------------------------------------------------------------------------------------------------
# Increment/Decrement
---------------------------------------------------------------------------------------------------------------
We can easily increment and decrement
a variable by 1 using the two operators

Example:
int age = 18;
// Here we increment the age variable by 1
age++;
// Output: 19
cout << age << endl;
// Here we decrement the age variable by 1
age--;
// Output: 18
cout << age << endl;

We can also add the operators
before the variable's name
The difference is that when
we add them before, increment/decrement
will be done before any other action

Example:
int age = 18;
// Here we are saying that
// we want the "new_age" variable
// To be equal to age and then
// increment the "age" variable by one
int new_age = age++;
// Here we are saying that
// we want to first increment
// the "age" variable by one
// and then add the value of that
// variable to the "newest_age" variable
int newest_age = ++age;
// Output: 20
cout << age << endl;
// Output: 18
cout << new_age << endl;
// Output: 19
cout << newest_age << endl;

---------------------------------------------------------------------------------------------------------------
# User input
---------------------------------------------------------------------------------------------------------------
To get input from a user we can use
the "cin" function and the extraction
operator (>>). When we give an input
we must store it so we'll be able to
use it later. We should also probably
print a prompt for the user

Example:
// Create a variable to store the input
int age;
// Crate the prompt for the user
cout << "Whats your age? ";
// This will store the user's input to the age variable
cin >> age;
// Print the variable that has user's input
cout << "Your age is " << age << endl;

cin will only take one word
If we wanna use spaces to get
the whole line we must use use
the getline() function

Example:
string name;
// Crate the prompt for the user
cout << "Whats your full name? ";
// This will store the user's input to the variable
getline(cin,name);
// Print the variable that has user's input
cout << "Your full name is " << name << endl;

Sometimes we may have problems
and we may need to clean and
ignore cin we do this with the
.clean() and .ignore() functions

Example:
// Clean
cin.clear();
// Ignore evrything
cin.ignore(numeric_limits<streamsize>::max(), '\n');

There is also the .get() method
which will wait for the user to press
the <enter> key to continue the program execution

Example:
cout << "This is the first line!" << endl;
// The program will stuck there
// utill you press the <enter> key
cin.get();
cout << "This is the second line!" << endl;

---------------------------------------------------------------------------------------------------------------
# Arrays
---------------------------------------------------------------------------------------------------------------
Arrays are used to store multiple values of the same data type
We define them by first specify their type, their name
and then using brackets ([]) to define how many elements the array will be able to hold
If we leave the brackets empty the array will be able to store
only the elements we give them when we created them
In the end we put the values inside curly brackets ({})

Example:
// It will create an array that stores intigers
int int_array[] = {0, 1, 2};
// It will create an array that stores strings
string string_array[] = {"name", "age", "hobbies"};
// It will create an array that stores up to 5 intigers
int big_array[5] = {0, 1, 2};
// Add another element to the 3rd index
// We can also use the index and the array name inside brackets
// 3[big_array] = 3;
big_array[3] = 3;
// Print the 2th element of the array
cout << big_array[3] << endl;

We can also store array inside arrays
we must specificy how many nested arrays
we want to have and how many elements they will have

Example:
// Crate an array that will store there elements that will be arrays
int nasted_array[3][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};
// Print the second element of the third nested array
cout << nasted_array[2][1] << endl;

To print every element of the
array we can use a for loop

Example:
// Create the array
int my_array[] = {13, 3, 12};
// The variable i will take every element
// of the array starting from the first to the last
for (int i: my_array) {
    cout << i << endl;
}

---------------------------------------------------------------------------------------------------------------
# Vectors
---------------------------------------------------------------------------------------------------------------
Vectors are like arrays but their length is
dynamic. We use them when we don't know how
many elements we will need to store. We must
include the <vector> header file to use them
We use the "vector" keyword, the type of values
we wanna store inside angular brackets (<>)
and finaly the name of the vector

Example:
// Include the vector header file
#include <vector>
// Create a vector that doesn't have space to store any elements
// Every time we try to add one element, it will increase it's
// capacity by one and store it
vector<int> my_vector;
// We can also explicitly give it a size to avoid copying
// Create a vector that has capacity to store three elements
// vector<int> my_vector(3);
// Add two values to the end of the vector
my_vector.push_back(1);
my_vector.push_back(3);
// Change the first element
my_vector[0] = 2;
// Print the last element
cout << my_vector[1] << endl;

To print every element of the
vector we can use a for loop

Example:
// Create the vector
vector<int> my_vector = {1, 2, 3};
// The variable i will take values 0 all the way up to vector's last element index
for (int i = 0; i < my_vector.size(); i++)
    cout << my_vector[i] << endl;

---------------------------------------------------------------------------------------------------------------
# STL Arrays
---------------------------------------------------------------------------------------------------------------
STL Arrays are arrays but they have some of the vector advanges
They still have a fixed type but we can now use methods with them
We must include the <array> header file to use them
We use the "array" keyword, the type of values and the length
inside angular brackets and finaly the name of the vector

Example:
// Include the array header file
#include <array>
// Create an array that will be able to store up to 10 elements
// In the beginning we will store two
array<int, 10> my_array = {10, 20};
// Define the value of the third element
my_array[2] = 30;
// Define the value of the forth element
my_array[3] = 30;
// Print the length of the array
cout << my_array.size() << endl;
// Print all the elements of the array
    for (int i = 0; i < my_array.size(); i++)
        cout << my_array[i] << endl;

---------------------------------------------------------------------------------------------------------------
# If statment
---------------------------------------------------------------------------------------------------------------
With if statements we will execute a
specific block of code if the given
condition it true. We use the "if"
keyword then the we put condition
inside parantheses (()) and finaly
we put the code inside curly brackets

Example:
// age variable is 18
int age = 18;
// if the age is bigger than 17 then execute the code
if (age > 17) {
    cout << "You are an adult!" << endl;
}

We use relational oparators to check values
Relational operators are used to compare two values
There are six in total

Equal operator(==)             Returns true if the two values are equal
Not equal(!=)                  Returns true if the two values are not equal
Greater than oparator(>)       Returns true if the value in the left is greater than the value in the right
Lesser than oparator(<)        Returns true if the value in the left is lesser than the value in the right
Greater than or equal to(>=)   Returns true if the value in the left is greater than or equal to the value in the right
Lesser than or equal to(<=)    Returns true if the value in the left is lesser than or equal to the value in the right

If the condition is false, we can specify an alternative code to be executed
with the "else" keyword

Example:
// age variable is 18
int age = 18;
// if the age is bigger than 17 then execute the code
if (age > 17) {
    cout << "You are an adult!" << endl;
// In any other case execute this alternative code
} else {
   cout << "You are not an adult" << endl;
}

If we want to check for an alternative condition to be ckecked
we can use the "else if" keyword
We can use as many as we want

Example:
// age variable is 18
int age = 18;
// if the age is bigger than 17 then execute the code
if (age > 17) {
    cout << "You are an adult!" << endl;
// In any other case execute this alternative code
} else if (age < 18) {
   cout << "You are not an adult" << endl;
}

We can test for two or more conditions
at the same time using logical operators

And(&&)  The operator returns true only if all the codicions return true
OR(||)   The operator returns true if at least one of the codicions return true
NOT(!)   The operator returns the inverse of the expression’s result (needs another set of parantheses)

Example:
string name = "John";
int age = 20;
// If age is equal to 'John' and also age is equal to 20 it will print this
if (name == "John" && age == 20) {
   cout << "Your name is John and you are 20 years old!" << endl;
// If the name is not equal to 'John' it will print this
} else if (!(name == "John")) {
   cout << "Your name is not John" << endl;
} else {
   cout << "I don't know who are you or how old are you!" << endl;
}

We can also check if something will return the excpected result

Exaple:
int num1;

// The num1 is intiger so we want an intiger value
// If we get an intiger input then execute this code
if (cin >> num1) {
    cout << "Accepted value" << endl;
// If the value is not an intiger then execute this code
} else {
    cout << "Not accepted value" << endl;
}

We can use the Ternary Operator to check a condition
and then return an exprasion for any of the two cases (true or false)
We write the condition (parantheses are optinal) and then a questionmark (?)
the what we want to return if the condition is true then colon
and finaly what we want to return if the condition is false
We can also have nested ternary operators

Exaple:
int age = 18;
string gender = "Male";
// Check if age is 18 or more, if it's true also check if the gender is male
// if this is also true then print the prashe else print the second prashe
// If the first condition (age >= 18) is false then print the second prashe
string adult = (age >= 18) ? (gender == "Male" ? "You are an adult an also a male"
: "You are an adult but not male") : "You are not an adult";
// Print the result
cout << adult << endl;

The Ternary operator can also be
used as an if statement alternative

Exaple:
int age = 18;
// if the age is 18 or bigger print the first else print the second
(age >= 18) ? cout << "You are an adult" : cout << "You are not an adult";
cout << age << endl;

---------------------------------------------------------------------------------------------------------------
# Switch statement
---------------------------------------------------------------------------------------------------------------
Switch is an alternative to if statement
We have one value and deferent cases of
what this value can and depending the case
we will execute the given code
We have to use the "break" keyword if we
want the statement to end when we find a case

Exaple:
int x = 5;

switch (x) {
    // If x == 1 execute this code
    case 1:
        cout << "X is 1" << endl;
        break;
    // If x == 2 execute this code
    case 2:
        cout << "X is 2" << endl;
        break;
    // In nothing of the other cases match then execute this
    default:
        cout << "X is something else" << endl;
}

---------------------------------------------------------------------------------------------------------------
# While loops
---------------------------------------------------------------------------------------------------------------
A while loop will loop if the
given codicion is true. It will
keep looping until the given
condition goes false. We use
them with the "while" keyword
and then we specify the condition
inside parantheses

Example:
int x = 0;
// Create a while loop that will loop as long as x is lesser than 5
while (x < 5) {
   cout << "Loop keeps going on!" << endl;
   // Add 1 to x in every loop so we can end the loop
   x++;
}

We can also execute the code at least once
and then check for the codicion
with the do while loop

Example:
int x = 0;
// The code here will executed
do {
   cout << "Loop keeps going on!" << endl;
   // Make x 8 so the while loop condition goes true
   x = 8;
// Then it will check the condition and if it's true then it will keep looping until it goes false
} while (x > 5);

---------------------------------------------------------------------------------------------------------------
# For loops
---------------------------------------------------------------------------------------------------------------
The for loop is used to loop through a specific range
The first value will be a variable to store every loops number
The second value will control how many loops we want to do
And the last value will be what we want to be executed after each loop

Example:
// First value: We crating the variable i that will get each loops number
// Second value: We will keep looping as long as i is lesser than 5
// Last value: After each loop we will increment i by one
for (int i = 0; i < 5; i++) {
    cout << i << endl;
}

We can also loop through any singe array/vector element
This is called a range based for loop

Example:
int my_arr[] = {12, 23, 3};
// In the first loop i will be 12 in the second it will be 23 etc.
for (int i: my_arr) {
cout << i << endl;
}

---------------------------------------------------------------------------------------------------------------
# Break and Continue
---------------------------------------------------------------------------------------------------------------
There are two specif words for loops and if statements
Break: It will break the current statement
Continue: It will skip all the other code and it will start the next loop

Example:
// Create a loop that i will takes values 0-9 and it will loop until i goes 9
for (int i = 0; i < 10; i++) {
    // If i is 7 or bigger break the loop
    if (i >= 7) {
        break;
    // If i is lesser than 4 skip the rest of the code
    } else if (i < 4) {
        continue;
    }

    // Increment i by 1
    i++;
}

---------------------------------------------------------------------------------------------------------------
# Functions
---------------------------------------------------------------------------------------------------------------
A function is a block of code that preforms a secific task
and we can re-use through our entire program
To create the function the first thing we must specify
is the type that the function is gonna return
If the function won't return anything we will use "void"

Example:
// Create a function that will print "hello world!"
void my_function() {
   cout << "Hello world!" << endl;
}

To use a function we have to call it
We do this be refaring to it's name

Example:
// This calls my_function function
my_function();

Functions can take parameters that we can change
every time we call the function and have different results
We have to define the type of the value
We can also pass defualt values for a parameter
in case don't get a value when the function is called

Example:
// Create a function that takes parameters a and b
void my_function (int a = 21, int b = 22) {
   int c = a + b;
   cout << "C is " << c << endl;
}

// Call my_fuction with a = 20 and b = 2
my_function(20, 2);
// Call my_fuction with a = 10 and b = 8
my_function(10, 8);
// Call my_fuction without parameters
my_function();

We can't create two functions that have
the same name and the same parameters
If we want to create two functions with
the same name we must either change the
parameter's type or use more parameters
so it knows which one to use.
This is called function overloading
and we can do as many times as we want

Example:
void my_function(string name) {
    cout << "This function has a string parameter" << endl;
    cout << "Your name is " << name << endl;
}

void my_function(int age) {
    cout << "This function has an int parameter" << endl;
    cout << "Your age is " << age << endl;
}

my_function("John");
my_function(18);

If we want to return something we use
the type of the value we want to return
instead of the "void keyword" and then
the "return" keyword in the value we want to return

Example:
// Create a function that will return an int
int my_function (int a, int b) {
   int c = a + b;
   // Return the value
   return c;
}

// Give variable d the value of c for my_function with a = 10 and b = 5
// Plus my_function with a = 5 and b = 0
int d = my_function(10, 5) + my_function(5, 0);
// Print the value of c if my_function a = 20 and b = 20
cout << "C is " << my_function(20, 20) << endl;
// Print d
cout << "D is " << d << endl;

We can have a function calling
itself, this is called recursion

Example:
int fact(int num) {
    if (num == 1) { return 1; }
    else {
        // The result will be nums
        // multiplied by the function
        // for argement we will give num minus 1
        // this will result for the function to
        // keep doing this untill the num goes 1
        // when it goes one it will break
        // and return the result
        int result = num * fact(num - 1);
        return result;
    }
}

cout << "Factorial of 4: " << fact(4) << endl;

---------------------------------------------------------------------------------------------------------------
# Scope
---------------------------------------------------------------------------------------------------------------
Every variable leaves untill the end
of it's scope. Things like functions,
if statments, for loops etc. create
their own scope. We can also create
a scope using curly brackets

Example:
// Variables declared outside any functions
// our called global variables and they will
// live throughout the end of the program
bool this_will_live_forever = true;

// The x variable will be created and
// then it will get destroyed when the
// function ends. This is the end of it's scope
void function() {
    int x = 10;
    cout << x << endl;
} // The variable x get's destroyed here

int main() {
    function();

    // The y variable will get destroyed after
    // the end of the if statment
    for (int i = 0; i < 3; i++) {
        // Every time the loops starts, it will create
        // the y variable and every time it ends, the y
        // variable will get destroyed and it will then
        // be created again in the next loop till the for
        // loops stops
        int y;
    } // The variable y will get destroyed here

    // Here we create our own scope without any
    // statment every variable created inside
    // this scope will be destroyed when they
    // reach the end of the scope
    // This must always be inside a function like main for example
    {
        int inside_x;
        int inside_y;
    } // The variables will get destroyed here
}

---------------------------------------------------------------------------------------------------------------
# Pointers
---------------------------------------------------------------------------------------------------------------
Pointers are special variables that
hold a memory address. To create a
pointer we use the asterisk after
the pointer's type (spaces does not
matter). To access a memory address
we use the ampersand (&)

Example:
int age = 18;
// Create a pointer that points to the address 0
void *null_pointer = 0;
// Create a double pointer. It points to the memory
// adresses of another pointer. We can also do a tripple
// pointer that points to the memory adresses of a double pointer etc.
void **double_pointer = &null_pointer;
// Create a pointer that will get the memory address of the variable age
int *pAge = &age;
// to create multiple pointers of
// the same type we must put an
// asterisk before each pointer
int *age2, *age3, *age4;
// Print the physical address of the variable's value
cout << &age << endl;

We can get the value that is store
in the memory address to manipulate
it with dereference. We use an
asterisk befor the pointer variable
or and asterisk and the ampersand if
we don't use a pointer variabele. This
is called dereference of the memory address

Example:
int age = 18;
int *agePointer = &age;
// Dereference the agePointer pointer and change age's value
*agePointer = 20;
// Print the pointer (memory address)
cout << agePointer << endl;
// Print the value of the pointer (value in the memory address)
cout << *agePointer << endl;
// Point the value age and also dereference it at the same time
*&age = 22;
cout << age << endl;

We can create an array of pointers
and have them hold different adresses

Example:
int num = 18;
int num2 = 19;
int num3 = 19;

// Create an pointer array
// to store this three memory adresses
int *nums_p[3] = {&num, &num2, &num3};

cout << "First adresses is: " << nums_p[0] << endl;
cout << "Second adresses is: " << nums_p[1] << endl;
cout << "Third adresses is: " << nums_p[2] << endl;

The values inside functions are
passed by value (except dynamic stuctures)
which means than we can't change
their values inside a function
To be able to do this we must
use a pointer a variable and
then dereference that pointer
to change the value it points to

Example:
// Here x will be a local variable, copy of the given value
void wont_change_x(int x) {
    x = 20;
}

// Here we pass x is a pointer that points to an adresses
void will_change_x(int *x) {
    // Dereference the pointer
    *x = 20;
}

int x = 10;
cout << "X is: " << x << endl;
// Here the function will copy "x" and it will
// crete a copy of it as a local variable. So
// in this case "x" won't change
wont_change_x(x)
cout << "X is still: " << x << endl;
// Here the function use a pointer to the memory
// adresses of "x" so it will then dereference
// it and change it's value
will_change_x(&x);
cout << "X is now: " << x << endl;

---------------------------------------------------------------------------------------------------------------
# Refrences
---------------------------------------------------------------------------------------------------------------
Refrences are similar to pointers
They are used to reference to a variable
We create them with the ampersand

Example:
// Create a variable
string name = "John";
// Create a reference to this variable
string &ref_name = name;
// Change the name's value
ref_name = "Not_John";
// Print name
cout << name << endl;

Example2:
// Create a function tha will increment a value
// It will take the reference of a value as a parameter
void Increment(int& value) {
    value++;
}

// Create the variable
int val = 18;
// Call the function and pass val as a parameter
Increment(val);
// Print val
cout << val << endl;

---------------------------------------------------------------------------------------------------------------
# Const
---------------------------------------------------------------------------------------------------------------
The keyword "const" tells the
program that we promise to not
modify the current variable or
pointer. If we try to modify it
the the program will not compile

Example:
// We promise to not modify this variable
const float PI = 3.14;
// Try to modify it and see what happens
PI = 3.15;
// When used with pointers, it can mean two things
int age = 18;
// This means that we won't be able to change the value
// of the memory location that this pointer points to
// but we can still change the memory that it points to
int const *mem_age = &age;
// This is the same thing
// const int *mem_age = &age;
// Try to dereference it and change the value and see what happens
*mem_age = 19;
// If the const is after the asterisk this means that we
// are able to dereference it and change the value but we
// are not able to point to another location
int *const val_point = &age;
// Try to point to another variable and see what happens
int age2 = 20;
val_point = &age2;
// If we add const before the asterike and after the
// asterike then it means that we can't do anything
int const *const pointer = &age;
// This is the same thing
// const int* const pointer = &age;
// Both of the following lines will result in an error
pointer &age2;
*pointer = 18;

If we create a const variable
and then we want to create in
a function that takes a pointer
or a refrence to this values then
we must also mark the funciton's
parameter as "const"

Example:
// Because this is a pointer to an
// adresses, we must mark it as "const"
// to be able to pass "const" variables
void print_val(const int *val) {
    cout << *val << endl;
}

// In this case, this will get passed by
// value so we don't need to mark it as "const"
void copy_val(int val) {
    cout << val << endl;
}

const float PI = 3.14;
print_val(&PI);
copy_val(PI);

---------------------------------------------------------------------------------------------------------------
# Header files
---------------------------------------------------------------------------------------------------------------
A header file is a file we can include in our cpp
file to be able to define functions from other files
and then include them and use them in other files
We can also create functions and variables in this
file and use it normally as it would be a normal file
The header file will store the decloration for all the
function from other files and we can just include this
header file and we will have access to every function
that has a decloration there. We use it with numbersign (#)
then the word include and angular brackets to search in
our include directories or double quotes to use a
releative path or include directories

Example:
// Filename: funcs.cpp
// Include functions from an include directory
#include <iostream>

using namespace std;

// Create a simple function
void Hello_World()
{
    cout << "Hello world!" << endl;
}

// Filename: headers.hpp
// This line tells the program to not include the same file multiple times
#pragma once

// We declare the function
void Hello_World();

// We will need to include the "funcs.cpp" file when compiling
// gcc main.cpp funcs.cpp -o main
// Note: change "gcc" with the compiler you use
// Filename: main.cpp
#include <iostream>
// Include the header file that has all the declorations
#include "headers.hpp"

using namespace std;

int main()
{
    // Use the function from the funcs.cpp file
    Hello_World();
}

---------------------------------------------------------------------------------------------------------------
# Static
---------------------------------------------------------------------------------------------------------------
Static mean different things based
of where it's used. When used for
local variables it means that this
variable can only be initialized once

Example:
for (i=0; i<6; i++) {
    // The variable will get
    // created once and won't
    // change to zero every time
    // we restart the loop
    static int x = 0;
    cout << x << endl;
    x++;
}

When used with global variables it
means that only this file will be
able to see this variable. The same
rule applies to function as well

// Filename: funcs.cpp
#include <iostream>
#include <string>

using namespace std;

// Create the static variable that
// only this file will be able to see
static string name = "John";

void print_name_static() {
    cout << "The name for the static file is: " << name << endl;
};

// Filename: static.hpp
#pragma once

// We only want to declare the function
// and not the variable because then the
// main file will be able to see it and it
// will give an error of conflict
void print_name_static();

// Filename: main.cpp
#include <iostream>
#include <string>
#include "static.hpp"

using namespace std;

string name = "Maria";

void print_name_main() {
    cout << "The name for the main file is: " << name << endl;
}

int main() {
    print_name_main();
    print_name_static();
}
---------------------------------------------------------------------------------------------------------------
# Exceptions
---------------------------------------------------------------------------------------------------------------
We can use the "try" keyword to try something
and in case we got an exception we can catch
the exception using the "catch" keyword and
the exception's type inside parantheses

Example:
string name = "John";

// Try to convert the name variable
// from string to float
try {
    int age = stof(name);
// If there is an error called "invalid_argument"
// make a reference to it and give the value to the "msg" variable
} catch (invalid_argument& msg) {
    cout << "The variable 'name' is not a number" << endl;
}

We can throw an exception using the
"throw" keyword and giving a massage

Example:
int age = 10;

// If the age is less than 18
if (age < 18) {
    throw("You are not an adult");
}

To be able to use the actual massage
we must combine try and trow keywords

// Try to throw an exception
try {
    throw("My massage!!!");
// The specif exceptions have a type called
// "const char*" and we give it's value to the msg
} catch (const char* msg) {
    cout << msg << endl;
}

---------------------------------------------------------------------------------------------------------------
# Templates
---------------------------------------------------------------------------------------------------------------
Tempates are used to tell the compiler how to use a code
We just create a template and the compiler will generate code
for us based on the type we want to use
To create them we use the "template" keyword and then
and then we define the template inside angular brackets
We can create them in things like functions to make
the same function accept different data types as parameters

Example:
// Create a template and give it the value T
template<typename T>
// Create a function that takes T as
// a parameter and acceptes any data type
void print(T value)
{
    cout << value << endl;
}

// Call the function with a string parameter
print("Hello world!");
// Call the function with an int parameter
print(18);
// Call the function with a float parameter
print(11.7);
// We can specify the type we wanna use iside angular brackets
print<bool>(true);

We can have a lot of
template arguments

Example:
// T will set the type of the member
// We want an iteger for the S type and
// it will hold the number of elements for the array
template<typename T, int S>
struct Array {
    T array[S]
};

// Create an array of 5 integers
Array<int, 5> int_arr;
// Create an array of 3 characters
Array<char, 3> char_arr;

We can create variadic templatized
functions which are functions that
can have infinite parameters

Example:
// This function will be called for the last argument
// Or it will be called if we only have one argument
template <typename T>
// After the last parameter we will always have a newline
void print(T val) {cout << val << endl;}

// Create a template that takes two typenames
// The second one must be three dots and a name
template <typename T, typename ... P>
// We must asume that we will have at least one parameter
// We may either not have a second one, have one, or have multiple
void print(T& first, P& ... val) {
    // This line we be excluded for every argument except the last one
    cout << first << " ";
    // For the last argument we must call another function so we can
    // control it and separate it from the others
    print(val...);
}

string name = "John";
int age = 20;
// Call the print function and give 2 parameters
print("Hello", name);
// Call the print function and give 4 parameters
print("Hello", name, "nice to meet you", "my friend!");
// Call the print function and give 6 parameters
print("Hello", name, "nice to meet you!", "Your age is", age, "right?");

---------------------------------------------------------------------------------------------------------------
# Classes
---------------------------------------------------------------------------------------------------------------
Classes let us create our own custom
data types. We use them to represent
real life objects. The have members
and each member has a value. We create
them using the "class" keyword and
then a name

Example:
// Create the class called ProgrammingLanguage
class ProgrammingLanguage {
    // Give it three members and make them public
    // More about public in the end but for now we just use this all the time
    public:
        string name;
        string creator;
        int created_date;
}

Classes act like a blueprint/template
of a data type. To create an instance
of this class we have to create an object
To create an object we use the name of
the class as a data type and then name
the object. Then we give each member of
the class a value using the object's name,
a dot (.) and the the member's name and
we asign a value to it. We can also change
every member's value for every object at any time

Example:
class ProgrammingLanguage {
    public:
        string name;
        string creator;
        int created_date;
};

// Create an object for this class
ProgrammingLanguage cpp;
// We can also use this syntax to
// give values to the members directly
// ProgrammingLanguage cpp = {"CPP", "Bjarne Stroustrup", 1985};
// Give a value to each member of the class
cpp.name = "C++";
cpp.creator = "Bjarne Stroustrup";
cpp.created_date = 1985;
// Print every member
cout << "cpp's name is: " << cpp.name << endl;
cout << "cpp's creator is: " << cpp.creator << endl;
cout << "cpp was created in: " << cpp.created_date << endl;
// Change cpp's name
cpp.name = "CPP";
// Print the new name
cout << "cpp's new name is: " << cpp.name << endl;
// If we use a pointer to a class
// we use the arrow operator (->)
// to access it's members
ProgrammingLanguage* point_person = &cpp;
cout << "This point's to the name: " << point_person->name << endl;

We can declare objects directaly in the end
of the structure and before the semicolon

Example:
// Create the struct
class ProgrammingLanguage {
    public:
        string name;
        string creator;
        int created_date;
// Create two objects directaly after the end of the stracture
} cpp, c;

// Define the members for the first object
ProgrammingLanguage cpp = {"C++", "Bjarne Stroustrup", 1985};

// Define the members for the second object
ProgrammingLanguage c = {"C", "Dennis Ritchie", 1972};

// Print the name member of the first object
cout << cpp.name << endl;
// Print the name member of the second object
cout << c.name << endl;

We can create a constructor for the class
A costructor is a function that's called
every time we will create an object

Example:
class ProgrammingLanguage {
    public:
        string name;
        string creator;
        int created_date;

    // The constuctor will take three arguments
    // and this arguments will be values for our class members
    ProgrammingLanguage(string aName, string aCreator, int aCreated_date) {
        // Assign the values to each member
        name = aName;
        creator = aCreator;
        created_date = aCreated_date;
    }

    // We can also use a deconstactor
    // that will be to deconstacte the object
    // This deconstactor will be called based of
    // if we have created the object on stack or on the heap
    // If we have created the object on the stack it will
    // get called when the scope ends for the object
    // If we have created the object on the heap it will
    // get deleted when we use the delete keyword and delete the object
    ~ProgrammingLanguage() {
        cout << "The object is deleted!" << endl;
    }
};

// Create a stuck alocated object
ProgrammingLanguage cpp("C++", "Bjarne Stroustrup", 1985);
// We can also define it this way
// ProgrammingLanguage cpp = ProgrammingLanguage("C++", "Bjarne Stroustrup", 1985);
// Create a heap alocated object
ProgrammingLanguage* cpp2 = new ProgrammingLanguage("C++", "Bjarne Stroustrup", 1985);
// Delete the object
delete cpp2;
cout << "The first object will go out of scope after this" << cpp.name << endl;

We can use member initializer lists
to set values for our members. We add
a colon after the parantheses and then
we set values to each member in order

Example:
class Person {
    public:
        string name;

        Person() { cout << "Creted object with no arguments" << endl; }

        Person(string pName) {
            cout << "Creted object with arguments!" << endl;
            name = pName;
        }
};

class ProgrammingLanguage {
    public:
        string name;
        string creator;
        int created_date;
        // When storing classes as members
        // It will create an object be default
        // and it will create a second object
        // based on the values we give the constructor
        // and it will replace. When using
        // initializer lists, it will only
        // create one
        Person p;

    // This constructor will be used in case
    // someone doesn't pass no arguments
    // We use initializer lists here
    ProgrammingLanguage()
        : name("Default"), creator("Someone"), created_date(3050), p("Random Guy") {} // or p(Person("Random Guy"))

    // This constructor will be used if someone passes arguments
    // We don't use initializer lists here
    ProgrammingLanguage(string pName, string pCreator, int pCreated_date, Person P) {
            name = pName;
            creator = pCreator;
            created_date = pCreated_date;
            p = P;
        }
};

// In this case we will use the first constructor so for the
// person struct, it will get constructed once with the initializer lists
ProgrammingLanguage def;
// In this case we are calling the second constructor
// but because we haven't used initializer lists, the
// class will create one Person object calling it's first
// constructor and then it will create another one based on
// the one we created here and it will replace the first one
ProgrammingLanguage pro = {"Language", "A guy", 2137, Person("A cool guy!")};

There is a special keyword called
"this". It is a pointer to the current
class so we can use it to reference
to the current class

Example:
// Declare the class so the funciton can see it exists
class Person;
// Declare the funciton so the class can see it exists
void give_info(Person *p);

void give_info(Person *p) {
    cout << "Object created!\n";
    cout << "Name: " << p->name << endl;
    cout << "Age: " << p->age << endl;
}

class Person {
    public:
        string name;
        int age;

    Person(string name, int age) {
            // Use the "this" keyword to say that we
            // want to access the "name" member from this
            // class instance. and we need to dereference
            // it because "this" is a pointer
            (*this).name = name;
            // Or we can use the arrow operator
            this->age = age;
            // Let's call the funciton that is outside this
            // class an pass this instance as a parameter
            // If we had passed the value as reference and
            // not as a pointer we would also had to dereference "this"
            give_info(this);
        }
};

void give_info(Person *p) {
    cout << "Object created!\n";
    cout << "Name: " << p->name << endl;
    cout << "Age: " << p->age << endl;
}

Person jack = Person("Jack", 21);

The program can implicitly convert
a value to call a constructor and
create an object. To not allow that
we can use the "explicit" keyword

Example:
class Person {
    public:
        string name;
        int age;

        Person(strin name) {
            this->name = name;
            this->age = 18;
        }

        // Set this constructor to not accepted implicit comversion
        explicit Person(int age) {
            this->name = "Default name";
            this->age = age;
        }
};

// We can create an object using a string
// because there is a constructor that needs
// a string and the program will comvert this
// value and call the constructor. Also the
// program can only do one implicit convert at
// the time so in this case we also need to convert
// the const char "Guy" to a string
Person sp = string("Guy");
// In the second constructor tho we have disabled
// this funcionality because we used the "implicit"
// keyword so we can't do that
Person ip = 28;

We can have static members inside
our class. Static members will be
the same for every object of our class

Example:
class Person {
    public:
        string name;
        int age;

        // Create a static member
        static int count;

        Person(string name, int age) {
            this->name = name;
            this->age = age;
            // Every time a new object is
            // created, increment the "count"
            count++;
        }
};

// Now we need to initialize the static member
int Person::count = 0;

auto mike = Person("Mike", 19);
auto john = Person("John", 19);
// Change the count from the "john" object
john.count = 10;
// this will also work (and makes more sense tbh)
// Person::count = 10;
// The variable has been
// changed for both objects
cout << mike.count << endl;
cout << john.count << endl;

We can create functions in our
class that are called methods

Example:
class Student {
    public:
        string name;
        int grades;

    Student(string name, int grades) {
        this->name = name;
        this->grades = grades;
    }

    // Create a function that checks if studens has more than 5 in their grades
    bool can_pass() {
        this->grade >= 5 ? return true : return false;
    }
};

// Create the first student that has a grade of 4
Student student1("John", 4);
// Create the second student that has a grade of 6
Student student2("Mike", 6);
// Check the results with the min_grades method and print them
cout << "Can this student pass?: " << student1.can_pass() << endl;
cout << "Can this student pass?: " << student2.can_pass() << endl;

We can add the const keyword in
a method to tell the program that
the method won't modify an class member

Example:
class Student {
    public:
        string name;
        int grades;

    Student(string aName, int aGrades) {
        name = aName;
        grades = aGrades;
    }

    // This method won't modify
    // any of the class members
    // so we can add the const
    // keyword after the parantheses
    bool can_pass() const {
        this->grade >= 5 ? return true : return false;
    }
};

Student student1("Anna", 10);
cout << "Can this student pass?: " << student1.can_pass() << endl;

We can use the mutable
keyword to let const
methods modify a member

Example:
class Person {
    public:
        string name;
        int age;
        // Create a mutable variable to count how many
        // times the info function has been used
        mutable int info_count;

    void info() const {
        cout << "Name: " << this->name << endl;
        cout << "Age: " << this->age << endl;
        // Even tho we use a const method, we
        // are allowed to modify this member
        info_count++;
    }
};

Person steve = {"Steve", 23, 0};
steve.info();
cout << steve.info_count << endl;

We can have static methods
that will only have access
to static class members

Example:
class Person {
    public:
        string name;
        int age;

        // Try to make this a normal
        // member to see what happens
        static int count;

        Person(string name, int age) {
            this->name = name;
            this->age = age;
            count++;
        }

        static void print_count() {
            cout << count << endl;
        }
};

int Person::count = 0;

// Call the static member
Person::print_count();

We can create a class that will
copy every member and method of
another class. This is called
inheritance and we call the new
class a derived class. If we define
a method we the same name in our
new class it will override the
one from the other class

Example:
class Chef {
    public:
        string name;
        int age;

        Chef(string name, int age) {
            this->name = name;
            this->age = age;
        }

        void makeChicken() {
            cout << "The chef makes chicken" << endl;
        }

        void makeSalad() {
            cout << "The chef makes salad" << endl;
        }
};

// Create a France Chef class that will have access
// to all Chef class functions plus it's own
class FrenchChef : public Chef {
    public:
        // When creating the constuctor for
        // our derived class, we also pass the values
        // for the constructor of the base class
        // and we don't do anything more for this class
        FrenchChef(string name, int age) : Chef(name, age) {}

        void makeFranceFood() {
            cout << "The France chef makes France food" << endl;
        }

        // Overide the function from the Chef class
        void makeSalad() {
            cout << "The France chef makes France salad" << endl;
        }
};

// Create the France Chef
FrenchChef franceChef("John", 18);
// franeChef uses a function from the Chef class
franceChef.makeChicken();
// franeChef uses a function from it's class
franceChef.makeFranceFood();

We can use a derived class when a
base class type is needed
This is called polymorphism

Example:
class Chef {
    public:
        string name;
        int age;

        Chef(string name, int age) {
            this->name = name;
            this->age = age;
        }
};

class FrenchChef : public Chef {
    public:
        FrenchChef(string name, int age) : Chef(name, age) {}
};

void print_info(Chef* c) {
    cout << "Chef's name is: " << c->name << endl;
    cout << "Chef's age is: " << c->age << endl;
}

auto chef = Chef("Marry", 22);
auto franceChef = FrenchChef("Mike", 19);
// Another thing we can do with polymorphism
// is to use the base class as a type and then
// use the constructor from our derived class
// Chef chef = FrenchChef("Mike", 19);
print_info(&chef);
// Even tho this function needs a pointer
// to a "Chef" class object, we can still
// use an object from a class that inherits
// from the "Chef" class like because of polymorphism
print_info(&franceChef);

If we have overide a function in a
derived class and use polymorphism then
the programm will use the function
from our base class. To change this
behavior we use virtual functions

class GreekChef {
    public:
        string name;

        GreekChef(string name) {
            this->name = name;
        }

        string ethnicity() {
            return "Greek";
        }

        // This function is virtual
        virtual string country() {
            return "Greece";
        }
};

class FrenchChef : public GreekChef {
    public:
        FrenchChef(string name) : GreekChef(name) {}

        string ethnicity() {
            return "French";
        }

        // The ovveride keyword here is
        // optinal but it helps with visibility
        // and also only virtual functions can use
        // that so if we make a typo, this will save us
        string country() override {
            return "France";
        }
};

void print_ethnicity(GreekChef* c) {
    cout << "Chef is: " << c->ethnicity() << endl;
}

void print_country(GreekChef* c) {
    cout << "Chef is from: " << c->country() << endl;
}

auto greekChef = GreekChef ("Anne");
auto frenchChef = FrenchChef("George");
// Even tho we have overide the function in
// our derived class, still because we use a type
// of "GreekChef", the program will still get
// the version of the function from our base class
print_ethnicity(&frenchChef);
// In this case we have used a virtual function
// and even tho we use a type of "GreekChef", the
// programm will use the function from the base class
print_country(&frenchChef);

We can use interfaces also called
pure virtual functions which let's
as specify some functions that our
derived class needs to always cretate in
order to be used

Example:
class PC {
    public:
        // This is a pure virtual function
        // and every class that inherits from
        // this class should provide that function
        virtual string info() = 0;
};

class AMD_PC : public PC {
    public:
        string info() override {
            return "This is an AMD PC!";
        }
};

class INTEL_PC : public PC {
    public:
        string info() override {
            return "This is an INTEL PC!";
        }
};

// We can no more use the "PC"
// class to create objects
AMD_PC amd;
INTEL_PC intel;
cout << amd.info() << endl;
cout << intel.info() << endl;

Be defualt the members of a class
are "private" which means that we
won't be able to access them outside
the class and other classes that
inherit from that class won't be
able to access them either. We can
also use "protected" which is
similar but other classes that
inherit from it will be able to use
them. And finaly there is "public"
which means that everyone has access
This is called encapsulation

Example:
class Person {
    // Everething is private be defualt so
    // this two members members are private
    string name;
    int age;
    // This member is protected
    protected:
        string ethnicity;
    // This constructor is public
    // so we can call it when initialize
    // the object and also the constructor
    // has access to all private and protected members
    public:
        Person(string name, int age, string ethnicity) {
            this->name = name;
            this->age = age ;
            this->ethnicity = ethnicity;
        }

        void print_info() {
            cout << "Name: " << this->name << endl;
            cout << "Age: " << this->age << endl;
            cout << "Ethnicity: " << this->ethnicity << endl;
        }
};

// When it comes to inheritance we can also specify
// the inheritance type for the base class (private by deafult)
// when deriving a class from a public base class,
// public members of the base class become public
// members of the derived class and protected members
// of the base class become protected members of the
// derived class. When deriving from a protected base
// class, public and protected members of the base
// class become protected members of the derived class.
// When deriving from a private base class, public
// and protected members of the base class become
// private members of the derived class.
class Person2 : public Person {
    // This derived class has access
    // to only protected or public
    // members from the base class
    public:
        Person2(string name, int age, string ethnicity) : Person(name, age, ethnicity) {}

        // The "ethnicity" member from the base class
        // is protected so we can access it
        void change_ethnicity(string new_ethnicity) {
            this->ethnicity = new_ethnicity;
        }
};

auto steve = Person("Steve", 23, "Italian");
auto david = Person2("David", 26, "Indian");
// Try to change the "name" or "age" members
// from any of the two objects and it will
// result in an error. Uncomment the next line
// cout << steve.name << endl;
// We can use only public members and methods
david.change ethnicity("Japanese");
steve.print_info();
cout << endl;
david.print_info();

---------------------------------------------------------------------------------------------------------------
# Structs
---------------------------------------------------------------------------------------------------------------
Structs are like Classes, the only difference
is that their members are public be defualt
We define them using the "struct" keyword

Example:
struct ProgrammingLanguage {
    string name;
    string creator;
    int created_date;
};

ProgrammingLanguage cpp = {"C++", "Bjarne Stroustrup", 1985};

cout << "cpp's name is: " << cpp.name << endl;
cout << "cpp's creator is: " << cpp.creator << endl;
cout << "cpp was created in: " << cpp.created_date << endl;

---------------------------------------------------------------------------------------------------------------
# Unions
---------------------------------------------------------------------------------------------------------------
Unions are a simple way to
create custom data types
they allocate only the space
that the biggest member needs
We can define a union with a
lot of members but they are
share the same place in memory
and changing a members value
will change the other members
value as well

Example:
// Create a union
union Data {
   int i;
   float f;
   // String type from C++
   // is not supported
   char str[12];
};

// Create a union called "data"
Data data;

// Assign values
// to the members
data.i = 10;
data.f = 220.5;
// For some reason we must use
// the "strcpy" function for strings (needs the "string.h" header file)
strcpy( data.str, "C Programming");

// See the results. It will be useful
// to use C's "printf" to format the
// text and change the way it appears
cout << "data.i : " << data.i << endl;
cout << "data.f : " << data.f << endl;
cout << "data.str : " << data.str << endl;

---------------------------------------------------------------------------------------------------------------
# Enums
---------------------------------------------------------------------------------------------------------------
Enums are another way to create
custom data types, we definde some
specific members the enum have
and then we create an object
that has one of this members
We create them using "enum" keyword

Example:
// Create a enum that will have this members avaliable
enum Languages {english, german, france, greek, italian};

// Create an Language type object that will have the greek member
Languages Greek = greek;

If we try to give the same member names to do different enums
it will create an error, to solve this we use enum class

// Create 2 enum classes with the same members
enum class Colors {red, green, blue};
enum class Colors2 {red, green, blue};

// Create an object that will have the red member from the second enum
Colors2 Red = Colors2::red;

---------------------------------------------------------------------------------------------------------------
# Define
---------------------------------------------------------------------------------------------------------------
We can say the compiler to treat
some words as like they were others
using the "#define" keyword

Example:
// Treat the INTIGER word
// as it was int, like an alias
#define INTIGER int

// Use the INTIGER word
INTIGER num = 18;
cout << "We created the number: " << num << " with the INTIGER word" << endl;

We can also define them
as constant values

Example:
// Treat the age word
// as it was 18
#define AGE 18
cout << "I am " << AGE << " years old" >> enld;

---------------------------------------------------------------------------------------------------------------
# File I/O
---------------------------------------------------------------------------------------------------------------
To create a file object, we use the "ofstream"
keyword then a name and then the file name we
wanna open iside double quotes and parantheses
Or we can first create the object and then use
the open() method to open a file. If they file
does not exist it will create it.
When we are done, we should also
close the file with the close() method

Example:
// Create a file object and open a file
ofstream my_file("new_file");
// Close the file
my_file.close();

To write something to the file we use file >>
It will delete everything in the file and it will add the new data

Example:
ofstream my_file("new_file");
// It will delete everything and it will add Hello world
my_file >> "Hello world!"
my_file.close();

If we don't want to delete the previous data and we want to append
we use another parameter when we create/open the file

Example:
// We use the ios::app to append data
ofstream my_file("new_file", ios::app);
my_file >> "This data will be appended to the file"
my_file.close();

To read from a file we use the "ifstream" keyword
We can use the get() method to get characters or the getline() function to get lines
If the file does not exist it will not create it

Example:
// Open the file for read
ifstream my_file("new_file");
// Create a char variable and store a character
char first_char = my_file.get();
// Create a string variable to store the line
string first_line;
// Save the line to the first_line variable
getline(my_file, first_line);
// Print the first_char variable
cout << first_char << endl;
// Print the first_line variable
cout << first_line << endl;

// Use a for loop to prit the whole file
while (my_file.good()) {
    getline(my_file, first_line);
    cout << first_line << endl;
}

---------------------------------------------------------------------------------------------------------------
# Operator overloading
---------------------------------------------------------------------------------------------------------------
We can overload operators to
teach the compiler how to use
them with custom data types
We create a method the has
the "operator" keyword and then
the operator we want to overload
after the return type

Example:
// Create a class that has two members and give them values
class Position {
    public:
        int x = 10;
        int y = 20;
        // Overload the "+" operator
        // It takes another object of the same type (as reference)
        // and it combines their members and returns
        // the result objects
        Position operator + (Position &pos) {
            Position new_pos;
            // The member x is equal to member x of the first object and the member x of the second object
            new_pos.x = this->x + pos.x;
            // The member y is equal to member y of the first object and the member y of the second object
            new_pos.y = this->y + pos.y;
            // Return the result
            return new_pos;
        }

        // Overload the "==" operator
        // This one compares two objects
        // of this type and returns true if
        // they are equal or false if they're not
        bool operator == (const Position &pos) {
            if (x == pos.x && y == pos.y) {
                return true;
            } else {
                return false;
            }
        }
};

// Create two object
Position pos1, pos2;
// Create a third object that is equal to the values of the first object
// plus the values of the second object
Position pos3 = pos1 + pos2;
cout << pos3.x << " " << pos3.y << endl;

We can also overloade built in
classes like cout, string, cin etc.

Example:
class Person {
    public:
        string name;
        int age;

   Person(string name, int age) : name(name), age(age) {}
};

// overloade the insertion operator
// to print a whole object at once
// We want to return an ostream object by reference
// and as parameters, take a reference to the "ostream"
// class because this is a definition outside of the class
// and we need to pass it by reference. We will also pass
// the "Person" class object by reference because we don't need
// to copy it then we will print what we want and finaly return the stream
ostream& operator << (ostream &output, const Person &person1) {
    cout << person1.name << endl;
    cout << person1.age << endl;
    return output;
}

// We can overloade the extraction
// operator with a similar way
// Do as before but now use an "istream"
// instead and cin to take input
istream& operator >> (istream &input, Person &person1) {
    cout << "What's your name: ";
    cin >> person1.name;
    cout << "What's your age: ";
    cin >> person1.age;
    return input;
}

Person output_person("John", 18);
// Print the object
cout << output_person;
Person input_person("John", 18);
// Use the operator and change the values
cin >> input_person;
cout << output_person;

---------------------------------------------------------------------------------------------------------------
# Command line parameters
---------------------------------------------------------------------------------------------------------------
To use command line arguments
we must give "argc" and "argv[]"
as parameters in the main function

// argc holds how many arguments was
// given when running the program
// argv is an array of strings
// holding the arguments
int main(int argc, char* argv[]) {
    // Print the number of arguments
    cout << argc << " arguments were given" << endl;

    // Loop through the argv array and print the arguments
    for (int i=0; i < argc; i++) {
        cout << "argument " << i << ": " << argv[i] << endl;
    }
}

---------------------------------------------------------------------------------------------------------------
# Namespaces
---------------------------------------------------------------------------------------------------------------
A namespace is like a name group for your functions
We can use them so we can group and orginize our functions better
and to be able to use function we the same name and define which one to use
We create them with the "namespace" keyword and then a name

Example:
// Create a namespace called hello
namespace hello {
    // Create a function called hello_world
    void hello_world() {
        cout << "Hello world!\n";
    }
}

// Create a namespace called alt_hello
namespace alt_hello {
    // Create a function with the same name
    void hello_world() {
        cout << "Hello world!\n";
    }
}

// Call the hello_world function from the alt_hello namespace
alt_hello::hello_world();

If we want to be able to use the a specif
namespace without typing the namespace
name we must use "using namespace" and
then the name of the namespace we want

Example:
namespace hello {
    void hello_world() {
        cout << "Hello world!\n";
    }
}

namespace alt_hello {
    void hello_world() {
        cout << "Hello world! (alt version)\n";
    }

    void hello_world2() {
        cout << "Hello world! (second version!!!)\n";
    }
}

// Use the hello namespace
using namespace hello;
// From the second namespace use only
// the second funciton without having
// to type the namespace name, the first
// function will still need to you to type
// the namespace name.
using alt_hello::hello_world2;

// Call the "hello_world" function without specify the namespace
// we can still type the namespace if we want but it's optinal now
hello_world();
// Call the "hello_world" function from the second namespace
alt_hello::hello_world();
// Call the "hello_world2" function from the
// second namespace without specify the namespace
hello_world2();

---------------------------------------------------------------------------------------------------------------
# Heap alocation
---------------------------------------------------------------------------------------------------------------
If we want a varible to not get
destroyed when it's scope ends
or if we want to store something
that is too big to get stored in
the stack then we can use the heap
We will allocate memory dynamically
in the heap and we will use a pointer
to this memory and we can then store
whatever we want in it. We use the
"new" keyword and then the data type
we want to allocate and based on the
type, "new" calculates the size for us
when we are done with the memory we and
we don't need it anymore then we are
responsible for cleaning it up. For that
we use the "delete" keyword to free up
the memory. Keep in mind that this will
free the memory but the actual pointer
itself lives in the stack so we will be
able to keep using it and point to anything
else we want. Also we must be careful
because in case we use another pointer
to point to the same memory adreess,
we can't delete them both cause this
will cause an error of trying to free
up memory that is already freed up


Example:
struct big_struct {
    string name = "Big Struct!";
    int numbers[1000000];
};

// This struct is to big to get stored in the stack (probably)
// so let's allocate memory for it in the heap and store it here
// It will also call the constructor and initialize the object
// Parantheses are optinal and in object's if the are not used
// it will call the constructor with no parameters. If used we can
// set values. For types like int if we don't give parantheses
// and we don't give it a value, it will get the default value
// for this type
big_struct* obj = new big_struct();
// We can normally use it as we would with any pointer
cout << "The name of the struct is: " << obj->name << endl;
obj->numbers[2] = 223;
cout << "We changed the value of the third number in the array to: " << obj->numbers[2] << endl;
// Use another variable to point to the same memory
// adress. We must NOT use delete in both of them
big_struct *point_to = obj;
// Clean up the memory now that we are done with it
// delete also calls the object's destructor
delete obj;

If we want to allocate an array we add
brackets after the data type and we also
add brackets after the "delete" keyword

Example:
struct big_struct {
    string name = "Big Struct!";
    int numbers[1000000];
};

// Allocate an array of characters
char* nums = new char[100];
// For objects we remove the parantheses
big_struct* alot_of_obj = new big_struct[10];
// If we want to do the same with an object we would do
big_struct* many_obj = new big_struct[10];
nums[2] = 'B';
cout << nums[2] << endl;
delete[] nums;
delete[] alot_of_obj;

---------------------------------------------------------------------------------------------------------------
# Smart pointers
---------------------------------------------------------------------------------------------------------------
Smart pointers are a way to
automate the proccess of
allocating memory in the heap
They will automatically free
the memory based on the type
of the pointer. We got three
and to get access to them we
need to include the "memory"
header file

1. Unique pointers
A unique pointer is a pointer
that will clean the memory when
it reaches the end of it's scope
We also can't copy a unique pointer

Example:
// Include the needed file (won't do this in the next examples)
#inuclude <memory>

struct Person {
    string name;
    int age;

    Person(string name = "Default", int age = 0) : name(name), age(age) {}

    ~Person() { cout << "The object was deleted!\n"; }
};

// I will create scopes for every example
{
    // Create a unique pointer of type "Person", parentheses are optinal
    unique_ptr<Person> john(new Person("John", 12));
    // Create an unique pointer of type "int"
    unique_ptr<int> num(new int);
    // This is another way and it's safer in case of exceptions
    // Parentheses are not optinal here
    // unique_ptr<Person> john = make_unique<Person>("John", 12);
    // Create an array of 4 "Person" objects
    unique_ptr<Person[]> persons(make_unique<Person[]>(4));

} // The unique pointers will automatically be deleted here

2. Shared pointers
A shared pointer works in the
same way as a unique pointer
but we can copy it. It uses
something called reference
cout which means that it couts
how many refrence why have on
this pointer and when it reaches
to zero then it frees the memory
when the pointer goes out of scope

Example:
struct Person {
    string name;
    int age;

    Person(string name = "Default", int age = 0) : name(name), age(age) {}

    ~Person() { cout << "The object was deleted!\n"; }
};

{
    // Create a shared pointer that pointes to null at first
    // we can also do this with unique pointers
    shared_ptr<Person> copy_pointer;
    {
        // The syntax is the same but we use "shared"
        // rather than "unique". Also in shared pointers,
        // it's better and more officient to use "make_shared" always
        shared_ptr<Person> john = make_shared<Person>("John", 12);
        // We will copy the share pointer to to the "copy_pointer"
        copy_pointer = john;

    } // The shared pointer "jonh" goes out of scope here but it won't get deleted
      // because we share it with another pointer and the reference count will go 1
} // The "copy_pointer" will go out of scope here so the reference count to "john" drops to 0 thus the memory gets freed

3. Weak pointers
Weak pointers can refrence a
shared pointer but they won't
increase their reference count

struct Person {
    string name;
    int age;

    Person(string name = "Default", int age = 0) : name(name), age(age) {}

    ~Person() { cout << "The object was deleted!\n"; }
};

{
    // Create a weak pointer, the same logic with the syntax
    weak_ptr<Person> no_refrence_pointer;
    {
        shared_ptr<Person> john = make_shared<Person>("John", 12);
        no_refrence_pointer = john;

    } // The shared pointer "jonh" is shared with "no_refrence_pointer" but it won't increase
      // it's reference count because it is a weak pointer so the memory gets freed here
}

---------------------------------------------------------------------------------------------------------------
# Copy
---------------------------------------------------------------------------------------------------------------
Whe we copy a variable that is
allocated in the stack, the new
variable will get a copy of the
variable. If it's an object, it
will get a copy of every member

Example:
struct Person {
    string name;
    int age;
};

string name = "John";
// This variable will get a copy of
// the "name" variable and they will be deferent
string copied_name = name;
// Changing the "copied_name" doesn't effect "name"
copied_name = "Mike";
cout << "The name is still: " << name << endl;
// The same thing works for objects
Person steve = {"Steve", 18};
Person anastasia = steve;
anastasia.name = "Anastasia";
cout << "Steve's name is still: " << steve.name << endl;


When it comes to objects however, when
we one of the members is a pointer that
uses memory in the heap, the copied object
will get copy the same pointer and thus point
to the same memory adreess. This can lead
to some problems and to fix this, we use
the copy constructor which is called every
time we copy an object

Example:
// This struct will have the default copy constructor
// and we won't create one by ourselves
struct Person {
    string name;
    // Use a pointer as a member
    int* age;

    Person(int age) : name("John") {
        // Allocate memory for this pointer and set the value
        this->age = new int(age);
    }
};

struct Person_deep {
    string name;
    int* age;

    Person_deep(int age) : name("John") {
        this->age = new int(age);
    }

    // This is the copy constructor and it always
    // returns an object of the same type and takes
    // a const refrence to an object of the same type
    // The refrence (Person_deep& p) is the object we are copying from
    Person_deep(const Person_deep& p) : name(p.name) { // We can set the name because it's not a pointer
        // Allocate new memory for the "age"
        // member of the new object and have it
        // take the value of the object we are copying from
        int* tmp = new int(*age);
        // Set the "age" member of the new
        // object to the new memory adresses
        // This is called a deep copy
        this->age = tmp;
    }

    // After the object goes out of scope, free the memory
    ~Person_deep() {
        delete this->age;
    }
};

// Let's try with the first struct
Person p0 = Person(20);
Person p1 = p0;
*p1.age = 17;
cout << "The age value of p0 has changed as well! It is: " << *p0.age << endl;

// Now let's try with the second struct
Person_deep p0_deep = Person_deep(20);
Person_deep p1_deep = p0_deep;
*p1_deep.age = 17;
cout << "The age value of p0 has NOT changed! It still is: " << *p0_deep.age << endl;
